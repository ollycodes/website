# Part 4: Forms and generic views

* Writing a minimal form
    - in **app/details.html**:
        ```python3
        <form action="{% url 'polls:vote' question.id %}" method="post">
        {% csrf_token %}
        <fieldset>
            <legend><h1>{{ question.question_text }}</h1></legend>
            {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}
            {% for choice in question.choice_set.all %}
                <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
                <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
            {% endfor %}
        </fieldset>
        <input type="submit" value="Vote">
        </form>
        ```
    - breakdown:
        * each radio button is tied to the choice's **ID**
        * but the name of each button is "choice"
        * that means that selecting a radio button & submitting will send:
            - the **POST** data **choice=#** where **#** is the **ID**
        * the form's **action** is set to `{% url 'polls:vote' question.id %}`
        * **method="post"**: the act of submitting this form will alter data server-side
            - good web development practice
        * forloop.counter indicates how many times for tag has gone through its loop
        * **POST** forms need to be protected from **Cross Site Request Forgeries**
            - all **POST** forms are targeted at interal URLs should use the
            - `{% csrf_token %}` template tag

    - update the **app/views.py**:
        ```python3
        from django.http import HttpResponse, HttpResponseRedirect
        from django.shortcuts import get_object_or_404, render
        from django.urls import reverse

        from .models import Choice, Question
        # ...
        def vote(request, question_id):
            question = get_object_or_404(Question, [pk](pk)=question_id)
            try:
                selected_choice = question.choice_set.get(pk=request.POST['choice'])
            except (KeyError, Choice.DoesNotExist):
                # Redisplay the question voting form.
                return render(request, 'polls/detail.html', {
                    'question': question,
                    'error_message': "You didn't select a choice.",
                })
            else:
                selected_choice.votes += 1
                selected_choice.save()
                
                # Always return an HttpResponseRedirect after successfully dealing
                # with POST data. This prevents data from being posted twice if a
                # user hits the Back button.
                return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
        
        def results(request, question_id):
            question = get_object_or_404(Question, pk=question_id)
            return render(request, 'polls/results.html', {'question': question})
        ```
    - breakdown
        * **request.POST**: a dict-like object, allows access to submitted data by key name
            - the values of this object always strings
            - note: django also provides `request.GET` for accessing GET data
            - but .POST ensure that data is only altered via a POST call
        * **request.POST['choice']**: returns the ID of the selected choice as a string
            - it will raise KeyError if the choice wasn't provided in POST data
            - then it will redisplay the question form with an error message
        * after incrementing count, the code returns **HettpResponseRedirect**
            - this takes a single argument - the URL to redirect the User to
            - always return a redirect after successfully dealing with POST data
        * **reverse()**: helps avoid having to hardcode a URL in the view function
            - reverse() will return a string like: '/app/3/results/'
            - 3 is the value of question.id
    
    - create a **results.html** template for the redirect:
        ```python3
        <h1>{{ question.question_text }}</h1>

        <ul>
        {% for choice in question.choice_set.all %}
            <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
        {% endfor %}
        </ul>

        <a href="{% url 'polls:detail' question.id %}">Vote again?</a>
        ```
    - note: vote() has a *race condition* problem that will be addressed later
        * if 2 users vote at the same time, vote will only increment by one


* Using Generic Views
    - detail() & results() are short and redundant, index() is also similar
    - to convert the current app to the generic views system:
        1. convert the URLconf
        2. Delete some of the old, unneeded views
        3. Introduce new views based on django's generic views

* Amend URLConf
    - in **app/urls.py** change the urlpatterns:
        ```python3
        # ...
        
        app_name = 'app'
        urlpatterns = [
            path('', views.IndexView.as_view(), name='index'),
            path('<int:pk>/', views.DetailView.as_view(), name='detail'),
            path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
            path('<int:question_id>/vote/', views.vote, name='vote'),
        ]
        ```
    - note: <question_id> was changed to <pk> for the view function amendment

* Amend views
    - in **app/views.py** replace index, detail, & result with generic views:
        ```python3
        # ...
        from django.views import generic

        # ...

        class IndexView(generic.ListView):
            template_name = 'polls/index.html'
            context_object_name = 'latest_question_list'

            def get_queryset(self):
                """Return the last five published questions."""
                return Question.objects.order_by('-pub_date')[:5]

        class DetailView(generic.DetailView):
            model = Question
            template_name = 'polls/detail.html'

        class ResultsView(generic.DetailView):
            model = Question
            template_name = 'polls/results.html'

        # ...
        ```
    - breakdown:
        * above code is using two generic views:
            - ListView: "display a list of objects"
            - DetailView: "display a detail page for a particular type of object"
        * `model`: each view needs to know what model it will act upon
        * `pk`: DetailView expects primary key value from the URL to be called "pk"
        * by default, DetailView uses a template called:
            - **<app name>/<model name>**_**detail.html**
            - the code above uses **app/question**_**detail.html**
            - it also specifies the template_name for the results list view
            - this ensures that the result & detail view have different appearances
        * previous templates have a context provided that contains:
            - the question and the latest_quesiton_list context variables
        * for DetailView, the question variable is provided automatically
            - since it uses the django model (Question)
            - it's also able to determine an appropriate name for the context variable
        * for ListView, the auto-generated context variable is: question_list
            - to override this, context_object_name attribute is provided
            - this points to latest_quesiton_list instead
        * as an alternative:
            - the templates could be changed to match the new default context variables
            - but that could cause confusion later down the line


[index](../index.md)
