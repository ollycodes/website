# Part 2: Models and the Admin site

* Database Setup
    - Django uses SQlite as its default
    - to use alternative database:
        * install appropriate database bindings (read docs)
        * in core/settings.py
            - change ENGINE
                * django.db.backends.sqlite3
                * django.db.backends.postgresql
                * django.db.backends.mysql
                * django.db.backends.oracle
                * or other database
            - change NAME (path to database; depends on your database)
            - additional settings may be required (USER, PASSWORD, HOST)
    - in core/settings
        * edit TIME_ZONE
        * add apps to INSTALLED_APPS
            - "app.apps.appConfig": app/apps.py -> appConfig class
            - "app": app folder
        * optional: comment out unneeded apps
    - migrate: `python manage.py migrate`
        * looks at INSTALLED_APPS
        * creates required databases

* Creating Models
    - Models: database layouts with metadata
    - Models follow DRY (Don't Repeat Yourself) principles
    - breakdown
        * `models.Model`: allows inheritance of database fields????
        * `models.CharField(max_length)`: character database field
        * `models.DateTimeField()`: datetime database field
        * `models.IntegerField()`: integer database field
        * `models.ForeignKey()`: many-to-one, two positional args required
            - related model; in this case, Question
            - on_delete: emulates the SQL constraint ON DELETE CASCADE behavior
        * `was_published_recently`: a custom method to the Question model
        * `__str__(self)`: provides human readable object name
            - add to every model!
    - for example, in **app/models.py**
        ```python3
        import datetime
        
        from django.db import models
        from django.utils import timezone
        
        class Question(models.Model):
            question_text = models.CharField(max_length=200)
            pub_date = models.DateTimeField('date published')
            
            def was_published_recently(self):
                return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
            
            def __str__(self):
                return self.question_text
        
        class Choice(models.Model):
            question = models.ForeignKey(Question, on_delete=models.CASCADE)
            choice_text = models.CharField(max_length=200)
            votes = models.IntegerField(default=0)
            
            def __str__(self):
                return self.choice_text
        ```
    - run model migration: `python manage.py makemigrations app`
        * makemigrations: updates models & stores changes in app/migrations/
        * migrate: runs and manages migrations automatically
        * sqlmigrate: takes migrations names & returns their SQL
            - doesn't migrate, only prints to screen
            - `python manage.py sqlmigrate app 0001`
        * things to note
            - table name = app_name + lowercase_model_name
            - Primary keys (IDs) are added automatically
            - Django appends "_id" to foreign key field names
    - finallly, migrate models to database: `python manage.py migrate`

* Summary
    1. change models in **app/models.py**
        - add __str__() to your models!
    3. `python manage.py makemigrations`
    4. `python manage.py migrate`

* playing with the API: `python manage.py shell`
    - manage.py sets DJANGO_SETTINGS_MODULE environment variables
        ```python3
        from polls.models import Choice, Question
        from django.utils import timezone
        
        Question.objects.all()
        # <QuerySet []>
        
        q = Question(question_text="What's new?", pub_date=timezone.now())
        q.save() # saves to database
        
        q.question_text
        # "What's New?"
        
        q.question_text = "What's up?"
        q.save()
        
        Question.objects.all()
        # <Question: What's up?>
        
        q = Question.objects.get(pk=1)
        q.was_published_recently()
        # True
        
        q.choice_set.all()
        # <QuerySet []>
        
        q.choice_set.create(choice_text='Not much', votes=0)
        q.choice_set.create(choice_text='The sky', votes=0)
        c = q.choice_set.create(choice_text='Just hacking again', votes=0)
        
        c.question 
        # Choice objects have API access to their related Quesiton object
        
        q.choice_set.all()
        # and vice versa
        q.choice_set.count()
        # 3
        
        # The API automatically follows relationships as far as you need.
        # Use double underscores to separate relationships.
        # This works as many levels deep as you want; there's no limit.
        # Find all Choices for any question whose pub_date is in this year
        # (reusing the 'current_year' variable we created above).
        Choice.objects.filter(question__pub_date__year=current_year)
        # <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
        
        c = q.choice_set.filter(choice_text__startswith='Just hacking')
        c.delete() # to delete a choice
        
        q.save()
        ```

* Creating an admin user
    1. `python manage.py createsuperuser`
    2. enter username
    3. enter email (optional)
    4. enter pw

* start development server
    1. `python manage.py runserver`
    2. http://127.0.0.1:8000/admin/

* make an app's model modifiable to the admin
    - in **app/admin.py**
        ```python3
        from django.contrib import admin
        
        from .models import Question
        
        admin.site.register(Quesiton)
        ```
    - forms are automatically generated based on the registered model
    - HTML input widgets are based on their corresponding field types
    - `DateTimeField` gets free Javascript shortcuts
    - there's a built-in history for revising changes


[index](../index.md)
