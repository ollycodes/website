# Part 3: Views and Templates

* Views: a "type" of webpage that serves a particular function
    - for example, a blog might have the following views:
        * Blog homepage
        * Entry detail page
        * year-based archive page
        * month-based archive page
        * day-based archive page
        * comment action
    - web pages & content is delivered by views
    - each view is represented by a python function (or method)
    - views are chosen by examining the requested URL via the "URLConfs" (urls.py)

* Writing a view
    - create view in **app/views.py**
        ```python3
        def index(request):
            latest_question_list = Question.objects.order_by('-pub_date')[:5]
            output = ', '.join([q.question_text for q in latest_question_list])
            return HttpResponse(output)
        # this is hardcodded; django argues that templates are better

        def detail(request, question_id):
            return HttpResponse("You're looking at question %s." % question_id)

        def results(request, question_id):
            response = "You're looking at the results of question %s."
            return HttpResponse(response % question_id)

        def vote(request, question_id):
            return HttpResponse("You're voting on question %s." % question_id)
        ```
    - wire views to **app/urls.py**
        ```python3
        from django.urls import path

        from . import views

        urlpatterns = [
            # /polls/ (because core/urls.py has /polls/ point here)
            path('', views.index, name='index'),
            # /polls/5/
            path('<int:question_id>/', views.detail, name='detail'),
            # /polls/5/results/
            path('<int:question_id>/results/', views.results, name='results'),
            # /polls/5/vote/
            path('<int:question_id>/vote/', views.vote, name='vote'),
            ]
        ```

* Creating a Template Namespace
    - create **templates/** directory in **app/** directory
    - **TEMPLATES** settings in **core/settings.py**
        * describe how templates will load & render
        * APP_DIRS: True -> allows django to look in **app/templates/** 
    - create **app/** directory in **templates/** directory
    - final path should be: **app/templates/app/**

* Template Namespacing
    - templates *could* be placed in **templates/** alone...
        * but if a template shared names with another app's templates,
        * like **app1/templates/index.html** vs **app2/templates/index.html**,
        * django would be unable to distinguish them from one another
        * therefore an **app1** and **app2** namespaced folder is required
    - namespacing: a set of signs (*names*) used to identify/refer objects uniquely

* Creating a template
    - in **app/templates/app/**, create **index.html** template & write:
        ```HTML
        {% if latest_question_list %}
            <ul>
            {% for question in latest_question_list %}
            <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
            {% endfor %}
            </ul>
        {% else %}
            <p>No polls are available.</p>
        {% endif %}
        ```
    - update index view in **app/views.py**:
        ```python3
        from django.http import HttpResponse
        from django.template import loader # used to load templates in app's template dir
        
        from .models import Question
        
        def index(request):
            latest_question_list = Question.objects.order_by('-pub_date')[:5]
            template = loader.get_template('polls/index.html')
            context = {
                'latest_question_list': latest_question_list,
            }
            return HttpResponse(template.render(context, request))
        ```

Left at Render        


[index](../index.md)
