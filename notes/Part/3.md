# Part 3: Views and Templates

* Views: a "type" of webpage that serves a particular function
    - for example, a blog might have the following views:
        * Blog homepage
        * Entry detail page
        * year-based archive page
        * month-based archive page
        * day-based archive page
        * comment action
    - web pages & content is delivered by views
    - each view is represented by a python function (or method)
    - views are chosen by examining the requested URL via the "URLConfs" (urls.py)

* Writing a view
    - create view in **app/views.py**
        ```python3
        def index(request):
            latest_question_list = Question.objects.order_by('-pub_date')[:5]
            output = ', '.join([q.question_text for q in latest_question_list])
            return HttpResponse(output)
        # this is hardcodded; django argues that templates are better

        def detail(request, question_id):
            return HttpResponse("You're looking at question %s." % question_id)

        def results(request, question_id):
            response = "You're looking at the results of question %s."
            return HttpResponse(response % question_id)

        def vote(request, question_id):
            return HttpResponse("You're voting on question %s." % question_id)
        ```
    - wire views to **app/urls.py**
        ```python3
        from django.urls import path

        from . import views

        urlpatterns = [
            # /polls/ (because core/urls.py has /polls/ point here)
            path('', views.index, name='index'),
            # /polls/5/
            path('<int:question_id>/', views.detail, name='detail'),
            # /polls/5/results/
            path('<int:question_id>/results/', views.results, name='results'),
            # /polls/5/vote/
            path('<int:question_id>/vote/', views.vote, name='vote'),
            ]
        ```

* Creating a Template Namespace
    - create **templates/** directory in **app/** directory
    - **TEMPLATES** settings in **core/settings.py**
        * describe how templates will load & render
        * APP_DIRS: True -> allows django to look in **app/templates/** 
    - create **app/** directory in **templates/** directory
    - final path should be: **app/templates/app/**

* Template Namespacing
    - templates *could* be placed in **templates/** alone...
        * but if a template shared names with another app's templates,
        * like **app1/templates/index.html** vs **app2/templates/index.html**,
        * django would be unable to distinguish them from one another
        * therefore an **app1** and **app2** namespaced folder is required
    - namespacing: a set of signs (*names*) used to identify/refer objects uniquely

* Creating a template
    - in **app/templates/app/**, create **index.html** template & write:
        ```HTML
        {% if latest_question_list %}
            <ul>
            {% for question in latest_question_list %}
            <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
            {% endfor %}
            </ul>
        {% else %}
            <p>No polls are available.</p>
        {% endif %}
        ```
    - update index view in **app/views.py**:
        ```python3
        from django.http import HttpResponse
        
        # used to load templates in app's template directory
        from django.template import loader 
        
        from .models import Question
        
        # standard way of loading a template, filling a context, 
        # & returning an HttpResponse object with the render result
        def index(request):
            latest_question_list = Question.objects.order_by('-pub_date')[:5]
            template = loader.get_template('polls/index.html')
            context = {
                'latest_question_list': latest_question_list,
            }
            return HttpResponse(template.render(context, request))
        ```
        * context: a dictionary that maps template variable names to python objects

* render(): a shortcut to the standard view function above
    - render() takes three arguments
        * request object
        * template name
        * dictionary (optional)
    - render() returns an HttpResponse object of:
        * the given template rendered
        * with the given context
    - in **app/views.py**:
        ```python3
        # note: .http & .template not needed, only render from .shorcuts
        # keep HttpResponse if it's needed for detail, results, vote methods
        from django.shortcuts import render

        from .models import Question

        def index(request):
            latest_question_list = Question.objects.order_by('-pub_date')[:5]
            context = {'latest_question_list': latest_question_list}
            return render(request, 'polls/index.html', context)
        ```

* Raising a 404 error
    - in **app/views.py** add:
        ```python3
        from django.http import Http404
        from django.shortcuts import render

        from .models import Question
        
        # ...
        
        def detail(request, question_id):
            try:
                question = Question.objects.get(pk=question_id)
            except Question.DoesNotExist:
                raise Http404("Question does not exist")
            return render(request, 'polls/detail.html', {'question': question})
        ```

* get_object_or_404(): a shortcut to the standard function above
    - get_object_or_404() takes two arguments:
        * a django model as first arg
        * an arbitrary number of keyword arguments
    - get_object_or_404() passes those args to get()
    - it raises Http404 if the object DNE
    - Django argues that shortcut is prefferred to:
        * catching the ObjectDoesNotExist at a higher level
        * having the Model API raise the 404 instead of ObjectDoesNotExist
    - Django design philosophy is in favor of loose coupling between 
        * the model layer & the view layer
        * some controlled coupling is introduced with .shortcuts
    - similar function: get_list_or_404(), uses filter() instead of get()
        * raises Http404 if list is empty


* Using the Template system
    - example of detail.html for detail() view
    - in **app/templates/app/detail.html** add:
        ```python3
        <h1>{{ question.question_text }}</h1>
        <ul>
        {% for choice in question.choice_set.all %}
            <li>{{ choice.choice_text }}</li>
        {% endfor %}
        </ul>
        ```
    - The template system uses **dot-lookup syntax** to access variable attributes
        * with `{{ quesiton.question_text }}` Dango:
            - does a dict lookup on the object question
            - failing that, it tries an attribute lookup--which works, in this case
        * Django uses Method-calling in the `{% for %}` loop
            - `question.choice_set.all` is interpreted as 
            - python code `question.choice_set.all()`
            - this returns an iterable of `Choice` objects

* Removing Hardcoded URLS in templates
    `<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>`
    - in "Creating a template" a URL was partially hardcoded in **templates/index.html**
    - as a project changes it becomes challenging to change template URLs
    - However:
        * each **path()** in **app/urls.py** has a name defined as its last argument
        * this allows it to be refferenced via `{% url %}` template tag
    `<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>`
    - Notice:
        * the URL path can be changed without editing the templates
            - in **app/urls.py**
            ```python3
            # previously: path('<int:question_id>/', views.detail, name='detail'),
            path('specifics/'<int:question_id>', views.detail, name='detail'),
            ```
        * the `{% url %}` tag requires any additional variable the view would need

* Namespacing URL names
    - IRL projects may have multiple apps, each may have their own *detail* view
    - How does django know which *detail* view to call when using the url tag?
    - the answer is to add **namespacing** to the app's URLconf (**app/urls.py**)
    - in **app/urls.py**, add 'app_name = app' above urlpatterns: 
        ```python3
        # ...
        
        app_name = 'app'
        urlpatterns = [
            # ...
        ]
        ```
    - in **app/index.html**, change 'detail' to 'app:detail':
        ```python3
        # previously, {% url 'detail' question.id %}
        <li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
        ```

[index](../index.md)
